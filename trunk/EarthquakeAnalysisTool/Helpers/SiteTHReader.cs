using System.Collections.Generic;
using System.IO;
using EqAT.Helpers;
using System;


namespace EqAT
{

    public struct SurfaceATHMakerOptions
    {
        /// <summary>
        /// Skip zero accelerations read in Shake91
        /// </summary>
        public bool IgnoreZeroAcc { get; set; }
        public string InputFilePath { get; set; }
    }

    /// <summary>
    /// ATH generated by Shake91 is processed using this class to generate a XYScatter chart in Excel
    /// </summary>
    public class SiteTHReader : FileProcessor
    {
        private string mPath;
        /// <summary>
        /// Acceleration Time Histories
        /// </summary>
        public List<string> ATH { get; private set; }
        /// <summary>
        /// Acceleration Time History in g
        /// </summary>
        public List<double> ATH_double { get; private set; }
        public List<double> VTH_Newmark { get; private set; }
        public List<double> DTH_Newmark { get; private set; }
        /// <summary>
        /// Newmark Displacement in mm
        /// </summary>
        public double NewmarkDisplacement { get; private set; }
        /// <summary>
        /// Time Interval in Milliseconds
        /// </summary>
        // public int DT { get; set; }
        /// <summary>
        /// Maximum Values that the ATH should hold
        /// </summary>
        public int MaxValues { get; set; }
        private SurfaceATHMakerOptions Options { get; set; }
        public string Title { get; set; }

        public SiteTHReader(SurfaceATHMakerOptions options)
        {
            ATH = new List<string>();
            ATH_double = new List<double>();
            VTH_Newmark = new List<double>();
            DTH_Newmark = new List<double>();

            // this.DT = 20;
            this.Options = options;
            this.MaxValues = 8 * 128;
            this.mPath = options.InputFilePath;
            this.WorkingDir = Path.GetDirectoryName(mPath);
        }

        /// <summary>
        /// Creates a column from an ATH file generated by Shake91
        /// </summary>
        public List<string> ReadATH()
        {
            ATH.Clear();

            using (StreamReader sr = new StreamReader(mPath))
            {
                string line = sr.ReadLine();
                this.Title = sr.ReadLine(); // Title

                while (!sr.EndOfStream && ATH.Count <= this.MaxValues)
                {

                    line = sr.ReadLine();
                    AddAccelerations(line);
                }
            }


            return ATH;
        }

        /// <summary>
        ///  Method to calculate Newmark Displacement
        /// </summary>
        /// <param name="dt">Timestep in seconds</param>
        /// <param name="ay">Yield Acceleration in g</param>
        public double NewmarkIntegrate(double dt, double ay)
        {

            double dispNewmark = 0.0;

            this.VTH_Newmark.Clear();
            this.DTH_Newmark.Clear();

            if (this.ATH_double.Count > 0)
            {
                int n = this.ATH.Count;
                double[,] accel = new double[n, 2];

                for (int i = 0; i < n; i++)
                {
                    accel[i, 0] = (double)i * dt;
                    accel[i, 1] = (this.ATH_double[i] - ay) * 9.81;
                }

                double[] area = new double[n];
                double[] velocity = new double[n];

                for (int i = 2; i < n; i++)
                {
                    if (accel[i, 1] >= 0)
                    {
                        if (accel[i - 1, 1] >= 0)
                        {
                            area[i] = dt * (accel[i, 1] + accel[i - 1, 1]) * 0.5;
                        }
                        else
                        {
                            double L2 = accel[i, 1] * dt / (accel[i, 1] + Math.Abs(accel[i - 1, 1]));
                            area[i] = L2 * 0.5 * accel[i, 1];
                        }
                    }
                    else
                    {
                        if (accel[i - 1, 1] < 0)
                        {
                            area[i] = 0;
                        }
                        else
                        {
                            double L2 = accel[i - 1, 1] * dt / (accel[i - 1, 1] + Math.Abs(accel[i, 1]));
                            area[i] = L2 * 0.5 * accel[i - 1, 1];
                        }
                    }

                    velocity[i] = area[i] + velocity[i - 1];
                }

                area = new double[n];

                double[] disp = new double[n];
                for (int i = 2; i < n; i++)
                {
                    area[i] = dt * (velocity[i] + velocity[i - 1]) * 0.5;
                    disp[i] = disp[i - 1] + area[i];
                }

                this.VTH_Newmark.AddRange(velocity);
                this.DTH_Newmark.AddRange(disp);


                foreach (double d in disp)
                {
                    dispNewmark += d;
                }

            }

            this.NewmarkDisplacement = dispNewmark;

            return dispNewmark;

        }

        public void WriteATH()
        {
            string dest = Path.Combine(Path.GetDirectoryName(mPath), Path.GetFileNameWithoutExtension(mPath) + "-for-excel.txt");
            StreamWriter sw = new StreamWriter(dest);
            foreach (string s in ATH)
            {
                sw.WriteLine(s);
            }
            sw.Close();
        }

        private void AddAccelerations(string line)
        {
            List<string> nums = SplitLine(line);
            for (int i = 0; i < nums.Count; i++)
            {
                ATH.Add(nums[i]);
                double d = 0.0;
                double.TryParse(nums[i], out d);
                this.ATH_double.Add(d);
            }
        }

        private List<string> SplitLine(string line)
        {
            char[] chars = line.ToCharArray();
            List<string> acc = new List<string>();

            if (chars.Length > 72)
            {
                for (int i = 0; i < chars.Length; i++)
                {
                    if (i + 9 > chars.Length)
                        return acc;

                    string num = line.Substring(i, 9);
                    if (this.Options.IgnoreZeroAcc)
                    {
                        double a = 0.0;
                        double.TryParse(num, out a);
                        if (a != 0)
                        {
                            acc.Add(num);
                        }
                    }
                    else
                    {
                        acc.Add(num);
                    }
                    i = i + 8;
                    if (acc.Count == 8)
                    {
                        return acc;
                    }
                }
            }

            return acc;
        }

        private bool IsValidLine(string line)
        {
            bool valid;
            valid = SplitLine(line).Count == 8;
            return valid;
        }


    }
}
